<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aurora Curtains</title>
  <style>
    :root {
      --sky-1: #0c1020;
      --sky-2: #1a2a44;
      --sky-3: #2a3f57;
      --mist-1: rgba(210, 230, 255, 0.8);
      --mist-2: rgba(180, 205, 235, 0.65);
      --mist-3: rgba(140, 170, 205, 0.5);
      --accent: #d8f1ff;
      --ink: #f4f7ff;
      --panel: rgba(10, 18, 32, 0.6);
      --panel-border: rgba(200, 220, 250, 0.18);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      min-height: 100vh;
      color: var(--ink);
      background: var(--sky-1);
      overflow: hidden;
    }

    #aurora {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: block;
    }

    .ui {
      position: relative;
      z-index: 2;
      display: flex;
      justify-content: flex-end;
      padding: 5vh 6vw;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: 18px 18px 16px;
      backdrop-filter: blur(12px);
      display: grid;
      gap: 14px;
      box-shadow: 0 20px 40px rgba(5, 10, 20, 0.35);
    }

    .panel h2 {
      font-size: 1rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      font-weight: 500;
      color: rgba(240, 248, 255, 0.9);
    }

    .control {
      display: grid;
      gap: 8px;
    }

    .control label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: rgba(230, 240, 255, 0.7);
      text-transform: uppercase;
    }

    .control input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .control input[type="number"] {
      width: 100%;
      border: 1px solid rgba(220, 235, 255, 0.2);
      background: rgba(15, 25, 40, 0.7);
      color: var(--ink);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.9rem;
    }

    .control input[type="color"] {
      width: 100%;
      height: 38px;
      border: 1px solid rgba(220, 235, 255, 0.2);
      border-radius: 10px;
      background: rgba(15, 25, 40, 0.7);
      padding: 4px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button {
      border: 1px solid rgba(220, 235, 255, 0.2);
      background: rgba(15, 25, 40, 0.7);
      color: var(--ink);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 0.85rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      background: rgba(20, 35, 55, 0.8);
    }

    .hint {
      font-size: 0.8rem;
      letter-spacing: 0.05em;
      color: rgba(220, 235, 255, 0.55);
    }

    @media (max-width: 900px) {
      .ui {
        justify-content: flex-start;
      }

      .panel {
        max-width: 360px;
      }
    }
  </style>
</head>
<body>
  <canvas id="aurora"></canvas>
  <div class="ui">
    <div class="panel">
      <h2>Controls</h2>
      <div class="control">
        <label for="backgroundTop">Background Top <span data-value="backgroundTop"></span></label>
        <input id="backgroundTop" type="color" value="#05070d" />
      </div>
      <div class="control">
        <label for="backgroundBottom">Background Bottom <span data-value="backgroundBottom"></span></label>
        <input id="backgroundBottom" type="color" value="#0c1626" />
      </div>
      <div class="control">
        <label for="auroraColorA">Aurora Color A <span data-value="auroraColorA"></span></label>
        <input id="auroraColorA" type="color" value="#49f2c2" />
      </div>
      <div class="control">
        <label for="auroraColorB">Aurora Color B <span data-value="auroraColorB"></span></label>
        <input id="auroraColorB" type="color" value="#8da8ff" />
      </div>
      <div class="control">
        <label for="seed">Seed <span data-value="seed"></span></label>
        <input id="seed" type="number" min="0" max="999999" value="58321" />
      </div>
      <div class="row">
        <div class="control">
          <label for="exportWidth">Export W <span data-value="exportWidth"></span></label>
          <input id="exportWidth" type="number" min="320" max="7680" value="2560" />
        </div>
        <div class="control">
          <label for="exportHeight">Export H <span data-value="exportHeight"></span></label>
          <input id="exportHeight" type="number" min="320" max="4320" value="1440" />
        </div>
      </div>
      <div class="control">
        <label for="intensity">Intensity <span data-value="intensity"></span></label>
        <input id="intensity" type="range" min="0" max="100" value="70" />
      </div>
      <div class="control">
        <label for="curtains">Curtain Count <span data-value="curtains"></span></label>
        <input id="curtains" type="range" min="2" max="20" value="9" />
      </div>
      <div class="control">
        <label for="thickness">Thickness <span data-value="thickness"></span></label>
        <input id="thickness" type="range" min="1" max="100" value="45" />
      </div>
      <div class="control">
        <label for="warp">Warp <span data-value="warp"></span></label>
        <input id="warp" type="range" min="0" max="100" value="55" />
      </div>
      <div class="control">
        <label for="layers">Layers <span data-value="layers"></span></label>
        <input id="layers" type="range" min="1" max="5" value="3" />
      </div>
      <div class="row">
        <button id="randomize" type="button">New Seed</button>
        <button id="download" type="button">Download PNG</button>
      </div>
      <div class="hint">Preview is following the export size</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("aurora");
    const inputs = {
      backgroundTop: document.getElementById("backgroundTop"),
      backgroundBottom: document.getElementById("backgroundBottom"),
      auroraColorA: document.getElementById("auroraColorA"),
      auroraColorB: document.getElementById("auroraColorB"),
      seed: document.getElementById("seed"),
      exportWidth: document.getElementById("exportWidth"),
      exportHeight: document.getElementById("exportHeight"),
      intensity: document.getElementById("intensity"),
      curtains: document.getElementById("curtains"),
      thickness: document.getElementById("thickness"),
      warp: document.getElementById("warp"),
      layers: document.getElementById("layers"),
    };

    const valueLabels = document.querySelectorAll("[data-value]");

    const params = {
      backgroundTop: inputs.backgroundTop.value,
      backgroundBottom: inputs.backgroundBottom.value,
      auroraColorA: inputs.auroraColorA.value,
      auroraColorB: inputs.auroraColorB.value,
      seed: Number(inputs.seed.value),
      exportWidth: Number(inputs.exportWidth.value),
      exportHeight: Number(inputs.exportHeight.value),
      intensity: Number(inputs.intensity.value),
      curtains: Number(inputs.curtains.value),
      thickness: Number(inputs.thickness.value),
      warp: Number(inputs.warp.value),
      layers: Number(inputs.layers.value),
    };

    const vertexSource = `#version 300 es
      precision highp float;
      out vec2 vUv;
      void main() {
        vec2 pos = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2);
        vUv = pos;
        gl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);
      }
    `;

    const fragmentSource = `#version 300 es
      precision highp float;
      out vec4 outColor;
      in vec2 vUv;

      uniform vec2 uResolution;
      uniform float uTime;
      uniform float uSeed;
      uniform vec3 uBackgroundTop;
      uniform vec3 uBackgroundBottom;
      uniform vec3 uAuroraA;
      uniform vec3 uAuroraB;
      uniform float uIntensity;
      uniform float uCurtains;
      uniform float uThickness;
      uniform float uWarp;
      uniform float uLayers;

      float hash21(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      float valueNoise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f * f * (3.0 - 2.0 * f);

        float a = hash21(i);
        float b = hash21(i + vec2(1.0, 0.0));
        float c = hash21(i + vec2(0.0, 1.0));
        float d = hash21(i + vec2(1.0, 1.0));

        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      float fbm(vec2 p) {
        float sum = 0.0;
        float amp = 0.5;
        float freq = 1.0;
        for (int i = 0; i < 6; i++) {
          sum += amp * valueNoise(p * freq);
          freq *= 2.03;
          amp *= 0.5;
        }
        return sum;
      }

      vec2 domainWarp(vec2 p, float strength) {
        vec2 q = vec2(fbm(p + vec2(1.7, 9.2)), fbm(p + vec2(8.4, 2.1)));
        vec2 r = vec2(fbm(p + q * strength + vec2(3.1, 5.4)),
                      fbm(p + q * strength + vec2(7.6, 1.8)));
        return p + r * strength;
      }

      float curtainField(vec2 p, float y, float layer, float thickness, float bands, float warp) {
        p.x += layer * 2.1;
        vec2 w = domainWarp(p * 1.1 + vec2(0.0, layer * 1.4), warp);
        float base = fbm(vec2(w.x * bands, layer * 3.1));
        float ridge = 1.0 - abs(base * 2.0 - 1.0);
        ridge = smoothstep(thickness * 0.6, 1.0, ridge);

        float streak = fbm(vec2(w.x * bands * 1.8, y * 6.0 + layer * 2.2));
        streak = smoothstep(0.15, 0.9, streak);

        float haze = fbm(vec2(w.x * bands * 0.6, y * 1.2 + layer * 1.7));
        haze = smoothstep(0.2, 0.8, haze) * 0.35;

        float vertical = smoothstep(0.02, 0.25, y) * (1.0 - smoothstep(0.65, 1.0, y));
        float taper = smoothstep(0.0, 0.35, y);
        return (ridge * streak + haze) * vertical * taper;
      }

      void main() {
        vec2 uv = vUv;
        vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);
        vec2 seedOffset = vec2(fract(uSeed * 0.1031), fract(uSeed * 0.1733)) * 20.0;
        vec2 p = (uv - 0.5) * aspect + seedOffset;

        vec3 background = mix(uBackgroundBottom, uBackgroundTop, uv.y);

        float bands = mix(3.0, 16.0, uCurtains);
        float thickness = mix(0.45, 0.08, uThickness);
        float warp = mix(0.05, 0.6, uWarp);
        float glow = 0.0;
        float weight = 0.0;
        for (int i = 0; i < 5; i++) {
          if (float(i) >= uLayers) {
            break;
          }
          float layer = float(i) / 4.0;
          float layerGlow = curtainField(p + layer * 0.35, uv.y, layer, thickness, bands + layer * 1.8, warp);
          float layerWeight = mix(1.0, 0.6, layer);
          glow += layerGlow * layerWeight;
          weight += layerWeight;
        }
        glow = glow / max(weight, 0.001);
        glow = pow(glow, 1.1) * uIntensity;

        float colorMix = fbm(vec2(p.x * 1.2, uv.y * 2.4 + 0.2));
        vec3 aurora = mix(uAuroraA, uAuroraB, colorMix);
        float baseBand = smoothstep(0.05, 0.3, uv.y) * (1.0 - smoothstep(0.45, 0.8, uv.y));
        vec3 color = background + aurora * glow;
        color += aurora * baseBand * 0.35;
        color += aurora * pow(glow, 2.0) * 0.9;

        outColor = vec4(color, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexSrc, fragmentSrc) {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
      if (!vertexShader || !fragmentShader) {
        return null;
      }
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    function createRenderer(targetCanvas) {
      const gl = targetCanvas.getContext("webgl2", { antialias: true, premultipliedAlpha: false });
      if (!gl) {
        return null;
      }
      const program = createProgram(gl, vertexSource, fragmentSource);
      if (!program) {
        return null;
      }
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.useProgram(program);

      return {
        gl,
        program,
        vao,
        uniforms: {
          resolution: gl.getUniformLocation(program, "uResolution"),
          time: gl.getUniformLocation(program, "uTime"),
          seed: gl.getUniformLocation(program, "uSeed"),
          backgroundTop: gl.getUniformLocation(program, "uBackgroundTop"),
          backgroundBottom: gl.getUniformLocation(program, "uBackgroundBottom"),
          auroraA: gl.getUniformLocation(program, "uAuroraA"),
          auroraB: gl.getUniformLocation(program, "uAuroraB"),
          intensity: gl.getUniformLocation(program, "uIntensity"),
          curtains: gl.getUniformLocation(program, "uCurtains"),
          thickness: gl.getUniformLocation(program, "uThickness"),
          warp: gl.getUniformLocation(program, "uWarp"),
          layers: gl.getUniformLocation(program, "uLayers"),
        },
      };
    }

    const renderer = createRenderer(canvas);
    if (!renderer) {
      throw new Error("WebGL2 not supported.");
    }

    function hexToRgb(hex) {
      const clean = hex.replace("#", "");
      if (clean.length !== 6) {
        return [0, 0, 0];
      }
      const r = parseInt(clean.slice(0, 2), 16) / 255;
      const g = parseInt(clean.slice(2, 4), 16) / 255;
      const b = parseInt(clean.slice(4, 6), 16) / 255;
      return [r, g, b];
    }

    function resize() {
      const exportWidth = Math.max(320, params.exportWidth);
      const exportHeight = Math.max(320, params.exportHeight);
      const scale = Math.max(window.innerWidth / exportWidth, window.innerHeight / exportHeight);
      canvas.width = exportWidth;
      canvas.height = exportHeight;
      canvas.style.width = `${Math.ceil(exportWidth * scale)}px`;
      canvas.style.height = `${Math.ceil(exportHeight * scale)}px`;
      renderer.gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function updateLabels() {
      valueLabels.forEach((label) => {
        const key = label.dataset.value;
        if (
          key === "backgroundTop" ||
          key === "backgroundBottom" ||
          key === "auroraColorA" ||
          key === "auroraColorB"
        ) {
          label.textContent = params[key].toUpperCase();
          return;
        }
        if (key === "exportWidth" || key === "exportHeight") {
          label.textContent = params[key];
          return;
        }
        if (key === "intensity") {
          label.textContent = `${params[key]}%`;
          return;
        }
        label.textContent = params[key];
      });
    }

    function setUniforms(targetRenderer, width, height, time) {
      const { gl, uniforms } = targetRenderer;
      const top = hexToRgb(params.backgroundTop);
      const bottom = hexToRgb(params.backgroundBottom);
      const auroraA = hexToRgb(params.auroraColorA);
      const auroraB = hexToRgb(params.auroraColorB);
      gl.useProgram(targetRenderer.program);
      gl.uniform2f(uniforms.resolution, width, height);
      gl.uniform1f(uniforms.time, time);
      gl.uniform1f(uniforms.seed, params.seed);
      gl.uniform3f(uniforms.backgroundTop, top[0], top[1], top[2]);
      gl.uniform3f(uniforms.backgroundBottom, bottom[0], bottom[1], bottom[2]);
      gl.uniform3f(uniforms.auroraA, auroraA[0], auroraA[1], auroraA[2]);
      gl.uniform3f(uniforms.auroraB, auroraB[0], auroraB[1], auroraB[2]);
      gl.uniform1f(uniforms.intensity, params.intensity / 100);
      gl.uniform1f(uniforms.curtains, params.curtains / 20);
      gl.uniform1f(uniforms.thickness, params.thickness / 100);
      gl.uniform1f(uniforms.warp, params.warp / 100);
      gl.uniform1f(uniforms.layers, params.layers);
    }

    function renderScene(targetRenderer, width, height, time) {
      const { gl } = targetRenderer;
      gl.viewport(0, 0, width, height);
      setUniforms(targetRenderer, width, height, time);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

    function applySettings() {
      params.backgroundTop = inputs.backgroundTop.value;
      params.backgroundBottom = inputs.backgroundBottom.value;
      params.auroraColorA = inputs.auroraColorA.value;
      params.auroraColorB = inputs.auroraColorB.value;
      params.seed = Number(inputs.seed.value);
      params.exportWidth = Number(inputs.exportWidth.value);
      params.exportHeight = Number(inputs.exportHeight.value);
      params.intensity = Number(inputs.intensity.value);
      params.curtains = Number(inputs.curtains.value);
      params.thickness = Number(inputs.thickness.value);
      params.warp = Number(inputs.warp.value);
      params.layers = Number(inputs.layers.value);
      updateLabels();
      resize();
      renderScene(renderer, canvas.width, canvas.height, 0);
    }

    Object.values(inputs).forEach((input) => {
      input.addEventListener("input", applySettings);
    });

    document.getElementById("randomize").addEventListener("click", () => {
      inputs.seed.value = Math.floor(Math.random() * 999999);
      applySettings();
    });

    document.getElementById("download").addEventListener("click", () => {
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = Math.max(320, params.exportWidth);
      exportCanvas.height = Math.max(320, params.exportHeight);
      const exportRenderer = createRenderer(exportCanvas);
      if (!exportRenderer) {
        return;
      }
      renderScene(exportRenderer, exportCanvas.width, exportCanvas.height, 0);
      exportCanvas.toBlob((blob) => {
        if (!blob) {
          return;
        }
        const link = document.createElement("a");
        const rand = Math.floor(1000 + Math.random() * 9000);
        link.download = `aurora_${params.seed}_${rand}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
      }, "image/png");
    });

    window.addEventListener("resize", () => {
      resize();
      renderScene(renderer, canvas.width, canvas.height, 0);
    });

    applySettings();
  </script>
</body>
</html>
